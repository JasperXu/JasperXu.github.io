# 程序静默运行

## 1. 静默执行

### 1.1. Windows

编译时调整为`go build - ldflags="-H windows"`

或使用 [NotificationTool](https://github.com/jasperxu/NotificationTool) 包一次。

### 1.2. Linux

```bash
# 静默启动，日志保存到app.log
nohup ./app > app.log 2>&1 &
```

## 2. 以服务方式随系统启动

### 2.1. Windows

使用 [WinSW](https://github.com/winsw/winsw) 包一次。

```bash
# 安装服务
WinSW install

# 卸载服务器
WinSW uninstall
```

下面是一个 go 程序的运行示例：

```xml
<configuration>
  <!-- ID of the service. It should be unique accross the Windows system-->
  <id>jx_ahmri_shenzhen</id>
  <!-- Display name of the service -->
  <name>JasperXu ahmri_shenzhen Service (powered by WinSW)</name>
  <!-- Service description -->
  <description>This service is a service for ahmri_shenzhen. Port:10247</description>

  <!-- Path to the executable, which should be started -->
  <executable>%BASE%\vp.exe</executable>
  <arguments></arguments>
  <logmode>reset</logmode>
  <workingdirectory>%BASE%</workingdirectory>
</configuration>
```

### 2.2. Linux

示例中服务为 `gofs` ，路径为 `/data/gofs` ， 执行文件名为 `gofs_linux_amd64` 。

```bash
# 编辑启动文件
sudo vi /etc/init.d/gofs
# 增加执行权限
sudo chmod +x /etc/init.d/gofs
# 加载启动脚本， defaults后还可以加数字，表示启动顺序号，多个服务依赖时有效。
sudo update-rc.d gofs defaults
# 使用
sudo service gofs { start | restart | stop | status }
# 查看
ps -ef | grep gofs
```

```bash
# 卸载启动脚本
sudo update-rc.d -f gofs remove
```

`/etc/init.d/gofs` 文件内容如下：

```bash
#!/bin/sh

### BEGIN INIT INFO
# Provides:          gofs
# Required-Start:    $network $local_fs $remote_fs $syslog $time
# Required-Stop:     $network $local_fs $remote_fs $syslog $time
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: start/restart/stop/status ahmri_xiamen
# Description:       start | restart | stop | status the ahmri_xiamen service
### END INIT INFO

# Conifg 配置服务名，路径，文件名，文件名带后缀
APP_NAME="gofs"
APP_PATH="/data/gofs"
APP_FILE="gofs_linux_amd64"
# PID文件和Log文件配置，默认即可。
APP_PID="/var/run/$APP_NAME.pid"
APP_LOG="$APP_PATH/$APP_NAME.log"
# 配置启动前缀和启动参数：例如APP_PRE_OPTION="java -jar"
APP_PRE_OPTION=""
APP_ARGS_OPTION=""

# 不能修改的配置
TMP_FILE="/tmp/status_$APP_NAME"

checkpid() {
    STATUS=9

    if [ -f $APP_PID ] ;
    then
        #echo "Is Running if you can see next line with $APP_NAME"
        ps -Fp `cat $APP_PID` | grep $APP_FILE > $TMP_FILE
        if [ -f $TMP_FILE -a -s $TMP_FILE ] ;
        then
            STATUS=0    #"Is Running (PID `cat $APP_PID`)"
        else
            STATUS=2    #"Stopped incorrectly"
        fi

        ## Clean after yourself
        rm -f $TMP_FILE
    else
        STATUS=1
        #"Not Running"
    fi

    return $STATUS
}

statusit() {
    checkpid
    STATUS=$?

    EXITSTATUS=""
    if [ $STATUS -eq 0 ] ;
    then
        EXITSTATUS="Is Running (PID `cat $APP_PID`)"
    fi
    if [ $STATUS -eq 1 ] ;
    then
        EXITSTATUS="Not Running"
    fi
    if [ $STATUS -eq 2 ] ;
    then
        EXITSTATUS="Stopped incorrectly"
    fi
    if [ $STATUS -eq 9 ] ;
    then
        EXITSTATUS="Default Status, should not be seen"
    fi

    echo $APP_NAME - $EXITSTATUS
}

start() {
    checkpid
    STATUS=$?

    if [ $STATUS -ne 0 ] ;
    then
        echo "Starting $APP_NAME..."
        nohup $APP_PRE_OPTION $APP_PATH/$APP_FILE $APP_ARGS_OPTION > $APP_LOG 2>&1 &
        echo PID $!
        echo $! > $APP_PID
        statusit
    else
        echo "$APP_NAME Already Running"
    fi
}

stop() {
    checkpid
    STATUS=$?

    if [ $STATUS -eq 0 ] ;
    then
        echo "Stopping $APP_NAME..."
        kill `cat $APP_PID`
        rm $APP_PID
        statusit
        #echo "Done"
    else
        echo "$APP_NAME - Already killed"
    fi
}

case "$1" in
start)
    start
    ;;
stop)
    stop
    ;;
restart)
    stop
    start
    ;;
status)
    statusit
    ;;
*)
    echo "Usage: $0 { start | restart | stop | status }"
    exit 1
    ;;
esac
exit 0
```
